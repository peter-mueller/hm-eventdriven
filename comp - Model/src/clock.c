/*****************************************************************************
* Model: comp.qm
* File:  ./src/clock.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/* @(/3/3) .................................................................*/
#include "qmbsp.h"
#include "alarm.h"
#include "clock.h"

#include <stdio.h>

Q_DEFINE_THIS_FILE

/* Local objects -----------------------------------------------------------*/
static AlarmClock l_alarmClock; /* the single instance of the AO */

/* Global-scope objects ----------------------------------------------------*/
QActive * const APP_alarmClock = &l_alarmClock.super; /* "opaque" pointer */

/* @(/2/3) .................................................................*/
void AlarmClock_ctor(void) {
}

/*..........................................................................*/
/* @(/2/1) .................................................................*/
/* @(/2/1/5) ...............................................................*/
/* @(/2/1/5/0) */
QState AlarmClock_initial(AlarmClock * const me, QEvt const * const e) {

    Time t = {0,0};
    (void)e; /* avoid compiler warning about unused parameter */

    me->current = t;

    /* (!) trigger the initial transition in the component */
    Alarm_init(&me->alarm);
    return Q_TRAN(&AlarmClock_showCurrentTime);
}
/* @(/2/1/5/1) .............................................................*/
QState AlarmClock_timekeeping(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1) */
        case Q_ENTRY_SIG: {
            /* periodic timeout every second */
            QTimeEvt_armX(&me->timeEvt, BSP_TICKS_PER_SEC,
                                        BSP_TICKS_PER_SEC);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->timeEvt);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/0) */
        case ALARM_SIG: {
            BSP_showMsg("Wake up!!!");
            status_ = Q_TRAN(&AlarmClock_brewing);
            break;
        }
        /* @(/2/1/5/1/1) */
        case TERMINATE_SIG: {
            BSP_showMsg("--> final");
            status_ = Q_TRAN(&AlarmClock_final);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/1/2) ...........................................................*/
QState AlarmClock_setBrewStrength(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1/2) */
        case Q_ENTRY_SIG: {
            BSP_showMsg("*** 12-hour mode");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/2/0) */
        case BUTTON_SIG: {
            me->strength = me->adval;
            status_ = Q_TRAN(&AlarmClock_enableAlarm);
            break;
        }
        /* @(/2/1/5/1/2/1) */
        case ADVal_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/1/3) ...........................................................*/
QState AlarmClock_showCurrentTime(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1/3) */
        case Q_ENTRY_SIG: {
            BSP_showMsg("*** 12-hour mode");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/3/0) */
        case TICK_SIG: {
            TimeEvt pe; /* temporary synchronous event for the component */

            me->current = timeAdd(me->current, 1);

            BSP_showTime24H("", me->current);

            pe.super.sig = TIME_SIG;
            pe.current = me->current;

            /* (!) synchronously dispatch to the orthogonal component */
            QHsm_dispatch(&me->alarm.super, &pe.super);

            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/3/1) */
        case BUTTON_SIG: {
            status_ = Q_TRAN(&AlarmClock_set_hour);
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/1/4) ...........................................................*/
QState AlarmClock_set_hour(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1/4/0) */
        case ADVal_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/4/1) */
        case BUTTON_SIG: {
            me->alarm.time.hour = me->adval;
            status_ = Q_TRAN(&AlarmClock_set_minute);
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/1/5) ...........................................................*/
QState AlarmClock_set_minute(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1/5/0) */
        case ADVal_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/5/1) */
        case BUTTON_SIG: {
            me->alarm.time.minute = me->adval;
            status_ = Q_TRAN(&AlarmClock_setBrewStrength);
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/1/6) ...........................................................*/
QState AlarmClock_enableAlarm(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1/6) */
        case Q_ENTRY_SIG: {
            BSP_showMsg("*** 12-hour mode");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/6/0) */
        case BUTTON_SIG: {
            QEvt *e =  Q_NEW(QEvt, ALARM_ON_SIG);
            QHsm_dispatch(&me->alarm.super, e);
            status_ = Q_TRAN(&AlarmClock_showCurrentTime);
            break;
        }
        /* @(/2/1/5/1/6/1) */
        case ADVal_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/1/6/2) .........................................................*/
QState AlarmClock_final(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1/6/2) */
        case Q_ENTRY_SIG: {
            QF_stop(); /* terminate the application */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_enableAlarm);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/2) .............................................................*/
QState AlarmClock_brewing(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/2/0) */
        case BUTTON_SIG: {
            status_ = Q_TRAN(&AlarmClock_timekeeping);
            break;
        }
        /* @(/2/1/5/2/1) */
        case TICK_SIG: {
            /* @(/2/1/5/2/1/0) */
            if (false) {
                status_ = Q_TRAN(&AlarmClock_timekeeping);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

