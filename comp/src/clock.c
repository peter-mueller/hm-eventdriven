/*****************************************************************************
* Model: comp.qm
* File:  ./src/clock.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/* @(/3/3) .................................................................*/
#include "qmbsp.h"
#include "alarm.h"
#include "clock.h"

#include <stdio.h>

Q_DEFINE_THIS_FILE

/* Local objects -----------------------------------------------------------*/
static AlarmClock l_alarmClock; /* the single instance of the AO */

/* Global-scope objects ----------------------------------------------------*/
QActive * const APP_alarmClock = &l_alarmClock.super; /* "opaque" pointer */

/* @(/2/3) .................................................................*/
void AlarmClock_ctor(void) {
    AlarmClock * const me = &l_alarmClock;

    QActive_ctor(&me->super, Q_STATE_CAST(&AlarmClock_initial));
    Alarm_ctor(&me->alarm); /* orthogonal component ctor */

    /* private time event ctor */
    QTimeEvt_ctorX(&me->timeEvt, APP_alarmClock, TICK_SIG, 0U);
}

/*..........................................................................*/
/* @(/2/1) .................................................................*/
/* @(/2/1/3) ...............................................................*/
/* @(/2/1/3/0) */
QState AlarmClock_initial(AlarmClock * const me, QEvt const * const e) {
    (void)e; /* avoid compiler warning about unused parameter */
    me->current_time = 0U;

    /* (!) trigger the initial transition in the component */
    Alarm_init(&me->alarm);
    return Q_TRAN(&AlarmClock_timekeeping);
}
/* @(/2/1/3/1) .............................................................*/
QState AlarmClock_timekeeping(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/3/1) */
        case Q_ENTRY_SIG: {
            /* periodic timeout every second */
            QTimeEvt_armX(&me->timeEvt, BSP_TICKS_PER_SEC,
                                        BSP_TICKS_PER_SEC);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/3/1) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->timeEvt);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/3/1/0) */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&AlarmClock_mode24h);
            break;
        }
        /* @(/2/1/3/1/1) */
        case CLOCK_24H_SIG: {
            status_ = Q_TRAN(&AlarmClock_mode24h);
            break;
        }
        /* @(/2/1/3/1/2) */
        case CLOCK_12H_SIG: {
            status_ = Q_TRAN(&AlarmClock_mode12h);
            break;
        }
        /* @(/2/1/3/1/3) */
        case ALARM_SIG: {
            BSP_showMsg("Wake up!!!");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/3/1/4) */
        case ALARM_SET_SIG: /* intentionally fall through */
        case ALARM_ON_SIG: /* intentionally fall through */
        case ALARM_OFF_SIG: {

            /* (!) synchronously dispatch to the orthogonal component */
            QHsm_dispatch(&me->alarm.super, e);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/3/1/5) */
        case TERMINATE_SIG: {
            BSP_showMsg("--> final");
            status_ = Q_TRAN(&AlarmClock_final);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/2/1/3/1/6) ...........................................................*/
QState AlarmClock_mode24h(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/3/1/6) */
        case Q_ENTRY_SIG: {
            BSP_showMsg("*** 24-hour mode");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/3/1/6/0) */
        case TICK_SIG: {
            TimeEvt pe; /* temporary synchronous event for the component */

            /* roll over in 24-hr mode? */
            if (++me->current_time == 24U*60U) {
                me->current_time = 0U;
            }
            BSP_showTime24H("", me->current_time, 60U);
            pe.super.sig = TIME_SIG;
            pe.current_time = me->current_time;

            /* (!) synchronously dispatch to the orthogonal component */
            QHsm_dispatch(&me->alarm.super, &pe.super);

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/3/1/7) ...........................................................*/
QState AlarmClock_mode12h(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/3/1/7) */
        case Q_ENTRY_SIG: {
            BSP_showMsg("*** 12-hour mode");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/3/1/7/0) */
        case TICK_SIG: {
            TimeEvt pe; /* temporary synchronous event for the component */

            /* roll over in 12-hr mode? */
            if (++me->current_time == 12U*60U) {
                me->current_time = 0U;
            }
            BSP_showTime12H("", me->current_time, 60U);
            pe.super.sig = TIME_SIG;
            pe.current_time = me->current_time;

            /* (!) synchronously dispatch to the orthogonal component */
            QHsm_dispatch(&me->alarm.super, &pe.super);

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/3/2) .............................................................*/
QState AlarmClock_final(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/3/2) */
        case Q_ENTRY_SIG: {
            QF_stop(); /* terminate the application */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

