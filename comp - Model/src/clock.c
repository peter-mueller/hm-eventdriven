/*****************************************************************************
* Model: comp.qm
* File:  ./src/clock.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/* @(/3/3) .................................................................*/
#include "qmbsp.h"
#include "alarm.h"
#include "clock.h"
#include "button.h"
#include "adc.h"

#include <stdio.h>

Q_DEFINE_THIS_FILE

/* Local objects -----------------------------------------------------------*/
static AlarmClock l_alarmClock; /* the single instance of the AO */

/* Global-scope objects ----------------------------------------------------*/
QActive * const APP_alarmClock = &l_alarmClock.super; /* "opaque" pointer */

/* @(/2/3) .................................................................*/
void AlarmClock_ctor(void) {
    AlarmClock * const me = &l_alarmClock;

    QActive_ctor(&me->super, Q_STATE_CAST(&AlarmClock_initial));
    Alarm_ctor(&me->alarm); /* orthogonal component ctor */

    /* private time event ctor */
    QTimeEvt_ctorX(&me->timeEvt, APP_alarmClock, TICK_SIG, 0U);
    button_setAO(&me->super);
    ad_setAO(&me->super);
}

/*..........................................................................*/
/* @(/2/1) .................................................................*/
/* @(/2/1/5) ...............................................................*/
/* @(/2/1/5/0) */
QState AlarmClock_initial(AlarmClock * const me, QEvt const * const e) {
    Set_RTC(&(me->current));
    Write_RTC(&(me->current));

    me->strength = 0U;
    me->adval = 0U;

    (void)e; /* avoid compiler warning about unused parameter */

    /* (!) trigger the initial transition in the component */
    Alarm_init(&me->alarm);
    return Q_TRAN(&AlarmClock_timekeeping);
}
/* @(/2/1/5/1) .............................................................*/
QState AlarmClock_timekeeping(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1) */
        case Q_ENTRY_SIG: {
            /* periodic timeout every second */
            QTimeEvt_armX(&me->timeEvt, BSP_TICKS_PER_SEC,
                                        BSP_TICKS_PER_SEC);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->timeEvt);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/0) */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&AlarmClock_showCurrentTime);
            break;
        }
        /* @(/2/1/5/1/1) */
        case ALARM_SIG: {
            BSP_showMsg("Wake up!!!");
            status_ = Q_TRAN(&AlarmClock_brewing);
            break;
        }
        /* @(/2/1/5/1/2) */
        case TERMINATE_SIG: {
            BSP_showMsg("--> final");
            status_ = Q_TRAN(&AlarmClock_final);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/1/3) ...........................................................*/
QState AlarmClock_setBrewStrength(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1/3) */
        case Q_ENTRY_SIG: {
            BSP_showMsg("Set the Brew Strength");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/3/0) */
        case BUTTON_DOWN_SIG: {
            //me->strength = me->adval;
            status_ = Q_TRAN(&AlarmClock_enableAlarm);
            break;
        }
        /* @(/2/1/5/1/3/1) */
        case AD_CHANGED_SIG: {
            ADEvt* evt = (ADEvt*)e;
            short newStrength = (evt->value)/(1024/5);
            if( newStrength != me->strength){
                me->strength = newStrength;
               // BSP_showTime24H(me->alarm.time);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/1/4) ...........................................................*/
QState AlarmClock_showCurrentTime(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1/4) */
        case Q_ENTRY_SIG: {
            BSP_showMsg("Show current time");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/4/0) */
        case BUTTON_DOWN_SIG: {
            status_ = Q_TRAN(&AlarmClock_set_hour);
            break;
        }
        /* @(/2/1/5/1/4/1) */
        case TICK_SIG: {
            Read_RTC(&(me->current));
            BSP_showTime24H(me->current);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/1/5) ...........................................................*/
QState AlarmClock_set_hour(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1/5) */
        case Q_ENTRY_SIG: {
            BSP_showMsg("Set the Hour");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/5/0) */
        case AD_CHANGED_SIG: {
            ADEvt* evt = (ADEvt*)e;
            short newHour = (evt->value)/(1024/23);
            if( newHour != me->alarm.time.hours){
                me->alarm.time.hours = newHour;
                BSP_showTime24H(me->alarm.time);
            }
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/5/1) */
        case BUTTON_DOWN_SIG: {
            //me->alarm.time.hour = me->adval;
            status_ = Q_TRAN(&AlarmClock_set_minute);
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/1/6) ...........................................................*/
QState AlarmClock_set_minute(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1/6) */
        case Q_ENTRY_SIG: {
            BSP_showMsg("Set the Minute");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/6/0) */
        case AD_CHANGED_SIG: {
            ADEvt* evt = (ADEvt*)e;
            short newMinutes = (evt->value)/(1024/59);
            if( newMinutes != me->alarm.time.minutes){
                me->alarm.time.minutes = newMinutes;
                BSP_showTime24H(me->alarm.time);
            }
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/6/1) */
        case BUTTON_DOWN_SIG: {
            //me->alarm.time.minute = me->adval;
            status_ = Q_TRAN(&AlarmClock_setBrewStrength);
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/1/7) ...........................................................*/
QState AlarmClock_enableAlarm(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/1/7) */
        case Q_ENTRY_SIG: {
            BSP_showMsg("Enable the Alarm?");
            status_ = Q_HANDLED();
            break;
        }
        /* @(/2/1/5/1/7/0) */
        case BUTTON_DOWN_SIG: {
            //QEvt *e =  Q_NEW(QEvt, ALARM_ON_SIG);
            //QHsm_dispatch(&me->alarm.super, e);

             //QACTIVE_POST(APP_alarmClock,
              //                       Q_NEW(QEvt, ALARM_ON_SIG), (void *)0);
            status_ = Q_TRAN(&AlarmClock_showCurrentTime);
            break;
        }
        /* @(/2/1/5/1/7/1) */
        case AD_CHANGED_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&AlarmClock_timekeeping);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/2) .............................................................*/
QState AlarmClock_brewing(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/2/0) */
        case BUTTON_DOWN_SIG: {
            status_ = Q_TRAN(&AlarmClock_timekeeping);
            break;
        }
        /* @(/2/1/5/2/1) */
        case TICK_SIG: {
            /* @(/2/1/5/2/1/0) */
            if (false) {
                status_ = Q_TRAN(&AlarmClock_timekeeping);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/2/1/5/3) .............................................................*/
QState AlarmClock_final(AlarmClock * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/1/5/3) */
        case Q_ENTRY_SIG: {
            QF_stop(); /* terminate the application */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

